#pragma config(Sensor, port3,  Gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port10, LED,            sensorVexIQ_LED)
#pragma config(Motor,  motor4,          FrontClaw,     tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor5,          RightDrive,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor6,          Convayor,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor11,         LeftDrive,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor12,         BackLock,      tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//The circomfrince of the wheel is 7.85
// 1 rotation is 7.85 inches
// 1 rotation is 360 degrees

void forwardMove(int distance, int speed){
	moveMotorTarget(LeftDrive, distance, speed);
	moveMotorTarget(RightDrive, distance, speed);
	//Holds program flow until the motor on port 1 comes to a complete stop.
	waitUntilMotorStop(LeftDrive);
	waitUntilMotorStop(RightDrive);
}
void backwardMove(int distance, int speed){
	moveMotorTarget(LeftDrive, -distance, -speed);
	moveMotorTarget(RightDrive, -distance, -speed);
	//Holds program flow until the motor on port 1 comes to a complete stop.
	waitUntilMotorStop(LeftDrive);
	waitUntilMotorStop(RightDrive);
}

void turnRightDist(float deg, int speed){
	int degToMove = (deg - 1);
	resetGyro(Gyro);
	motor[LeftDrive] = speed;
	motor[RightDrive] = -speed;
	waitUntil(getGyroDegreesFloat(Gyro) <= -degToMove);
	stopMotor(LeftDrive);
	stopMotor(RightDrive);
	if(getGyroDegreesFloat(Gyro) < -degToMove) {
		motor[LeftDrive] = -10;
		motor[RightDrive] = 10;
		waitUntil(getGyroDegreesFloat(Gyro) >= -degToMove);
		stopMotor(LeftDrive);
		stopMotor(RightDrive);
	}
}

void turnLeftDist(float deg, int speed){
	int degToMove = (deg - 1);
	resetGyro(Gyro);
	motor[LeftDrive] = -speed;
	motor[RightDrive] = speed;
	waitUntil(getGyroDegreesFloat(Gyro) >= degToMove);
	stopMotor(LeftDrive);
	stopMotor(RightDrive);

	if(getGyroDegreesFloat(Gyro) > degToMove) {
		motor[LeftDrive] = 10;
		motor[RightDrive] = -10;
		waitUntil(getGyroDegreesFloat(Gyro) <= degToMove);
		stopMotor(LeftDrive);
		stopMotor(RightDrive);
	}

}

void waitForTouch(){
	setTouchLEDColor(LED, colorRed);
	waitUntil(getTouchLEDValue(LED) == 1);
	setTouchLEDColor(LED, colorGreen);
}

void firstGreen(){
	motor[Convayor] = 100;
	moveMotorTarget(FrontClaw, -1000, -100);
	backwardMove(64, 10);
	sleep(500);
	forwardMove(60, 10);
	sleep(500);
	forwardMove(20,50);

	turnRightDist(90,30);
	forwardMove(290,30);
	turnLeftDist(130,30);
	forwardMove(173,30);
	moveMotorTarget(FrontClaw, 900, 50);
	forwardMove(200,50);
	turnRightDist(49,30);
	forwardMove(218,50);
	//turnLeftDist(10,15);
	moveMotorTarget(FrontClaw,-400,-50);
	waitUntilMotorMoveComplete(FrontClaw);
	backwardMove(155,30);
}

void secondGreen(){
	moveMotorTarget(FrontClaw,-1000,-1000);
	turnRightDist(60,30);
	forwardMove(345,30);
	turnRightDist(89,30);
	forwardMove(178,30);
	moveMotorTarget(FrontClaw, 800, 50);
	forwardMove(200,50);
	turnRightDist(110,30);
	forwardMove(370,30);
	turnLeftDist(101,20);
	//forwardMove(50,30);
	moveMotorTarget(FrontClaw, 900, 50);
	forwardMove(100,30);
	moveMotorTarget(FrontClaw, -200, -50);
	forwardMove(10,30);
	waitUntilMotorMoveComplete(RightDrive);
	backwardMove(90,50);
	stopAllMotors();
}

void getThirdGreen() {
	motor[Convayor] = 100;
	moveMotorTarget(FrontClaw, -1000, -100);
	forwardMove(12,50);

	turnLeftDist(90,50);
	forwardMove(295,30);
	turnRightDist(133,50);
	forwardMove(175,30);
	moveMotorTarget(FrontClaw, 900, 50);
	forwardMove(200,50);
	turnLeftDist(46,30);
	forwardMove(240,50);
	//turnLeftDist(10,10);
	moveMotorTarget(FrontClaw,-400,-50);
	waitUntilMotorMoveComplete(FrontClaw);
	backwardMove(200,50);
}

task main()
{
	waitForTouch();
	firstGreen();
	secondGreen();
	waitForTouch();
	getThirdGreen();
}
